2016-18829 Seongmin Lee / 이성민
ligi214@snu.ac.kr

자료구조의 기초 homework5

1. Compile 방법
'g++ *.cpp'로 컴파일하면 a.out 이라는 실행 파일이 만들어진다.
'./a.out' 을 입력함으로써 프로그램을 실행시킬 수 있다.
컴파일을 하기 위한 Makefile을 이용해, 'make'를 입력해서도 컴파일할 수 있다.

2. Input file
Input graph는 input.txt 파일에 입력한다. 이 때, 입력하는 순서는 pdf에 설명된 것과 같다.
첫 번째 line에는 vertex 개수를,
두 번째 line에는 edge 개수를,
세 번째 line부터는 edge들을 입력한다.
Edge는 weight,start node,end node 순서로 입력한다.
예를 들어, 3,1,2 로 입력이 들어왔다면 vertex#1->vertex#2인 edge가 있으며, 그 weight는 3임을 의미한다.
,와 숫자 사이는 띄어쓰기가 없다.

3. Visualization detail
과제에 네 개의 문제가 나왔기 때문에, 프로그램을 시작하면 네 개 중 한 문제를 골라 풀이를 볼 수 있다.
처음에 숫자를 입력하라는 창이 출력되고, 해당 입력란에 5를 입력하면 프로그램이 종료된다. 1, 2, 3, 4 중 하나를 입력하면 input.txt에 입력한 그래프에 대한 해답이 출력되고 다시 첫 화면(입력을 받는 화면)으로 돌아온다.
Directed/Undirected 여부에 대해서는 언급된 바가 없으므로, 1번 문제와 2번 문제는 directed, undirected 모두에 대해 일을 수행하였고, 3번은 undirected만, 4번은 directed인 경우에 대해서만 해답을 출력하도록 하였다. 각각의 visualization detail은 아래와 같다.

- Question 1. Depth first search (Problem 6.2-3)
First case : Directed graph, Second case : Undirected graph로 나누어 solution을 보여준다.
Depth first search는 각 vertex마다 discovered time과 finish time을 갖는다. 각각을 d_time, f_time으로 출력하였다. 각 vertex 번호마다 어떤 time을 갖는지와 더불어 predecessor를 출력하도록 하였다. Predecessor는 depth first search를 할 때, 해당 vertex에 오기 바로 직전에 어느 vertex에서 비롯되었는지를 말한다. 이를 참고함으로써 depth first tree의 형태를 파악할 수 있다.
문제에서 준 조건과 같이 edge의 정보는 adjacency list 형태로 들어온다고 가정하였다. 이 문제에서는 입력된 weight는 아무런 영향을 미치지 않는다.

- Question 2. Breadth first search (Problem 6.2-5)
Depth first search와 마찬가지로 주어진 그래프가 directed일 때와 undirected일 때로 나누어 해답을 보여준다.
Breadth first search는 각 vertex마다 search를 시작한 source로부터의 거리 값을 갖고 있다. 이를 d로 각 vertex마다 출력하도록 하였다. 그와 더불어, predecessor 정보를 보여주어 breadth first tree의 구조를 파악할 수 있도록 하였다. Predecessor는 어느 vertex에 대해 search를 할 때, 해당 vertex에 도달하였는지를 말해준다. 즉, breadth first tree의 parent vertex라고 생각할 수 있겠다.
문제에서 준 조건과 같이 edge의 정보는 adjacency list 형태로 들어온다고 가정하였다. 이 문제에서는 입력된 weight는 아무런 영향을 미치지 않는다.

- Question 3. Minimum spanning tree (Problem 6.3-3)
Minimum spanning tree 문제는 undirected graph가 들어온다고 가정하였다.
이를 풀 때에는 각 vertex마다 TV에 add될 때 갖고 있던 key 값을 갖고 있으므로, 이를 출력하도록 하였다. 또한, predecessor도 함께 출력함으로써 minimum spanning tree가 어떻게 생겼는지를 파악 가능하다. Vertex u에 대한 predecessor가 v라면 edge (u,v)가 minimum spanning tree를 구성한다고 생각할 수 있다. Source vertex에 대해서는 NIL을 출력하도록 하였다.
마지막에는 total key를 출력하여 minimum spanning tree의 weight 합을 보여주었다.
만일, spanning tree가 없다면, 즉 connected 되지 않은 input이 들어왔다면 spanning tree가 존재하지 않는다는 메시지를 띄웠다.

- Question 4. Single source shortest path (Problem 6.4-8)
이 문제에서는 directed graph가 들어옴을 가정하였으며, 문제에서 제시된 알고리즘에 맞추기 위해 adjacency matrix가 들어온다고 생각하였다.
주어진 source에 대해 각 vertex까지 가는 shortest path와 그 path의 length를 출력하는 문제이다.
Source vertex는 해당 vertex가 source임을 출력하였고, reachable하지 않은 vertex는 path가 없다는 메시지를 출력하였다.
나머지 reachable한 vertex에 대해서는 source부터 그 vertex까지 가는 최단 경로와 거리를 출력하였다.

- 5를 입력하면 종료가 되며, 1~5 외의 입력을 주면 잘못된 입력이 들어왔다는 에러 메시지가 뜬다.